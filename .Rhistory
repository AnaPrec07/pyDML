### FUNCIONES GENÉRICAS AUXILIARES
# Función para generar puntos de dimensión arbitraria en cierto intervalo de forma uniforme.
# Argumentos:
# N: Número de puntos
# dims: Dimensión de los puntos
# rango: Intervalo donde se generan los puntos
# Salida: Matriz Nxdims representando al conjunto de puntos.
simula_unif = function (N=2,dims=2, rango = c(0,1)){
m = matrix(runif(N*dims, min=rango[1], max=rango[2]),
nrow = N, ncol=dims, byrow=T)
m
}
# Función para generar puntos de dimensión arbitraria siguiendo una distribución normal con media 0.
# Argumentos:
# N: número de puntos
# dims: Dimensión de los puntos
# sigma: Vector con el rango de las varianzas
# Salida: Matrix nxdim representando al conjunto de puntos.
simula_gaus = function(N=2,dim=2,sigma,mu = 0){
if (missing(sigma)) stop("Debe dar un vector de varianzas")
sigma = sqrt(sigma)  # para la generación se usa sd, y no la varianza
if(dim != length(sigma)) stop ("El numero de varianzas es distinto de la dimensión")
simula_gauss1 = function() rnorm(dim, sd = sigma, mean = mu) # genera 1 muestra, con las desviaciones especificadas
m = t(replicate(N,simula_gauss1())) # repite N veces, simula_gauss1 y se hace la traspuesta
m
}
# Función que simula de forma aleatoria los parámetros {a,b} de una recta y=ax+b
# Argumentos:
# intervalo: Intervalo donde se simulan los puntos que determinan la recta
# visible: Si es TRUE, se dibujará la recta
# Salida: vector con los parámetros {a,b} de la recta
simula_recta = function (intervalo = c(-1,1), visible=F){
ptos = simula_unif(2,2,intervalo) # se generan 2 puntos
a = (ptos[1,2] - ptos[2,2]) / (ptos[1,1]-ptos[2,1]) # calculo de la pendiente
b = ptos[1,2]-a*ptos[1,1]  # calculo del punto de corte
if (visible) {  # pinta la recta y los 2 puntos
if (dev.cur()==1) # no esta abierto el dispositivo lo abre con plot
plot(1, type="n", xlim=intervalo, ylim=intervalo)
points(ptos,col=3)  #pinta en verde los puntos
abline(b,a,col=3)   # y la recta
}
c(a,b) # devuelve el par pendiente y punto de corte
}
# Función para pintar la frontera de una función
# Argumentos:
# f: función sobre la que se pinta su frontera
# rango: intervalo mostrado en el dibujo
pintar_frontera = function(f,rango=c(-50,50), xlab = "x", ylab = "y", col = "black" ) {
x=y=seq(rango[1],rango[2],length.out = 100)
z = outer(x,y,FUN=f)
if (dev.cur()==1) # no esta abierto el dispositivo lo abre con plot
plot(1, type="n", xlim=rango, ylim=rango)
contour(x,y,z, levels = 0, drawlabels = FALSE,xlim =rango, ylim=rango, xlab = xlab, ylab = ylab, col = col)
}
# Función que, dado un conjunto de puntos del plano y una recta, genera etiquetas para cada punto según
# el semiplano determinado por la recta en que se encuentren.
# Argumentos:
# datos: Matriz con los puntos del plano
# recta: vector con los coeficientes a,b de una recta y=ax+b
# Salida: Vector de etiquetas, con tantos elementos como puntos tenga datos.
# Los valores de la etiqueta serán 1, -1 o 0, según el punto se encuentre en el semiplano superior, inferior, o
# la propia recta, respectivamente.
generar_etiquetas_recta = function(datos, recta){
etiquetas <- vector('integer',length(datos))
etiquetas <- sign(datos[,2]-recta[1]*datos[,1]-recta[2])
return(etiquetas)
}
# Función que obtiene los coeficientes (a,b) de una recta en la forma y = ax + b a partir de los coeficientes (A,B,C) de la recta en la ecuación Ax+By+C = 0
coefs_recta_explicita <- function(coefs_recta_impl){
return(c(-coefs_recta_impl[1]/coefs_recta_impl[2],-coefs_recta_impl[3]/coefs_recta_impl[2]))
}
# Función que aplica el peso de regresión sobre el dato dado
eval_peso <- function(dato, peso){
dato%*%peso
}
# Función que calcula el error de clasificación
# Argumentos:
# datos: Matriz de datos
# etiquetas: Vector de etiquetas
# pesos: Coeficientes de la recta de regresión.
# Salida: valor numérico del error
# Se asume que las entradas de los tres argumentos tienen dimensiones correctas
calcular_error_mal_clasif <- function(datos,etiquetas,pesos){
N <- length(etiquetas)
f_datos <- apply(X = datos, FUN = eval_peso, MARGIN = 1, pesos)
mal_clasif <- sum(sign(f_datos) != etiquetas)
return(mal_clasif*100.0/N)
}
# Función que evalúa el grado de simetría de una matriz (respecto del eje vertical)
# Argumentos: A - Matriz a evaluar
# Salida: Valor real con el grado de simetría
fsimetria <- function(A){
A = abs(A-A[,ncol(A):1]) # Diferencia con la imagen simétrica
mean(A)                  # Media de las diferencias (grado de simetría)
}
# Lectura de los datos (test)
digits.test <- read.table("./datos/zip.test")
digits48.test <- digits.test[digits.test$V1 == 4 | digits.test$V1 == 8,]
cifras.test <- digits48.test[,1]
ndigitos.test = nrow(digits48.test)
grises.test = array(unlist(subset(digits48.test,select=-V1)),c(ndigitos.test,16,16))
# Calculamos vector de intensidades
intensidades.test <- apply(X = grises.test, FUN = mean, MARGIN = 1)
# Calculamos vector de simetrías
simetrias.test <- apply(X = grises.test, FUN = fsimetria, MARGIN = 1)
rm(digits.test)
rm(digits48.test)
#Obtenemos la matriz de datos
datos_dig.test <- matrix(c(intensidades.test,simetrias.test), nrow = length(intensidades.test), ncol = 2)
label_dig.test <- rep(1,length(cifras.test))
label_dig.test[cifras.test==8]<- -1
digits.test
datos_dig.test
digits.test <- read.table("./datos/zip.test")
digits48.test <- digits.test[digits.test$V1 == 4 | digits.test$V1 == 8,]
cifras.test <- digits48.test[,1]
ndigitos.test = nrow(digits48.test)
grises.test = array(unlist(subset(digits48.test,select=-V1)),c(ndigitos.test,16,16))
intensidades.test <- apply(X = grises.test, FUN = mean, MARGIN = 1)
simetrias.test <- apply(X = grises.test, FUN = fsimetria, MARGIN = 1)
grises.test
